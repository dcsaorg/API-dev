{
  "name": "DCSA-OpenAPI",
  "description": "",
  "spectralExtends": [],
  "extends": [],
  "formats": [
    "oas2",
    "oas3",
    "oas3.0",
    "oas3.1"
  ],
  "aliases": {
    "DCSA_CarrierBookingReference": {
      "id": "8NV1az5ddgeoWlM8mtkq5",
      "description": "Matching all `carrierBookingReference`",
      "name": "DCSA_CarrierBookingReference",
      "targets": [
        {
          "formats": [
            "oas3"
          ],
          "given": "$.components.schemas..carrierBookingReference"
        }
      ]
    },
    "DCSA_EquipmentReference": {
      "id": "Rk8HViehOioBDOPD3_WMd",
      "description": "Matching all `equipmentReference`",
      "name": "DCSA_EquipmentReference",
      "targets": [
        {
          "formats": [
            "oas3"
          ],
          "given": "$.components.schemas..equipmentReference"
        }
      ]
    },
    "DCSA_NonObjects": {
      "id": "wf_LHod3Y0nLDIuQp-ZaV",
      "description": "Matching all `DCSA` recognized simpleTypes",
      "name": "DCSA_NonObjects",
      "targets": [
        {
          "formats": [
            "oas3"
          ],
          "given": "$.components.schemas..properties.*"
        }
      ]
    }
  },
  "rules": {
    "simpleType-validation-CarrierBookingReference": {
      "id": "wUWx-vIj_G31P-ky8vaVf",
      "given": [
        "#DCSA_CarrierBookingReference"
      ],
      "severity": "error",
      "then": [
        {
          "function": "equals",
          "functionOptions": {
            "value": "string"
          },
          "field": "type"
        },
        {
          "function": "equals",
          "functionOptions": {
            "value": 35
          },
          "field": "maxLength"
        },
        {
          "function": "equals",
          "functionOptions": {
            "value": "^\\S+(\\s+\\S+)*$"
          },
          "field": "pattern"
        },
        {
          "function": "noRefInSimpleType"
        }
      ],
      "name": "simpleType-validation-CarrierBookingReference",
      "description": "The `carrierBookingReference` **MUST** be:\r\n* type: `string`\r\n* pattern: `^\\S+(\\s+\\S+)*$`\r\n* maxLength: `35`\r\n* cannot be defined using a $ref",
      "message": "{{error}}"
    },
    "simpleType-validation-check-DCSA-compatibility": {
      "id": "NcwDDKQv7GMS6sOLgRGBu",
      "given": [
        "#DCSA_NonObjects"
      ],
      "severity": "error",
      "then": {
        "function": "checkRequirements",
        "field": "type"
      },
      "name": "simpleType-validation-check-DCSA-compatibility",
      "description": "Check DCSA allowed properties",
      "message": "{{error}}",
      "resolved": false
    }
  },
  "x-embeddedFunctions": [
    {
      "id": "g2DJi6h7xrIe-ljcGXDj6",
      "extendedFrom": "",
      "name": "equals",
      "content": "import { createRulesetFunction } from '@stoplight/spectral-core';\n\nexport default createRulesetFunction(\n  {\n    input: null,\n    options: {\n      type: \"object\",\n      additionalProperties: false,\n      required: [\"value\"],\n\n      properties: {\n        value: {\n          type: [\"string\", \"integer\"]\n        }\n      }\n    },\n  },\n  // https://github.com/stoplightio/spectral/blob/develop/docs/guides/5-custom-functions.md#writing-functions\n  function equals(input, options, context) {\n    const { value } = options;\n\n    const propertyName = context.path[[context.path.length - 2]];\n    const propertyProperty = context.path[[context.path.length - 1]];\n    if (input !== undefined) {\n      if (input !== value) {\n      return [\n        {\n          message: propertyName + `.` + propertyProperty + `: value must equal \"${value}\", value provided: \"${input}\".`,\n        },\n      ];\n      }\n    } else {\n      return [\n        {\n          message: propertyName + `.` + propertyProperty + `: value must equal \"${value}\" no value provided!`,\n        },\n      ];\n    }\n  },\n);"
    },
    {
      "id": "UPXI6GiG0IVwCQgFhjc4t",
      "extendedFrom": "",
      "name": "noRefInSimpleType",
      "content": "import { createRulesetFunction } from '@stoplight/spectral-core';\n\nexport default createRulesetFunction(\n  {\n    input: null,\n    options: null,\n  },\n  // https://github.com/stoplightio/spectral/blob/develop/docs/guides/5-custom-functions.md#writing-functions\n  function noRefInSimpleType(input, options, context) {\n    if (Object.keys(input).length === 1 && input['$ref']) {\n      const propertyName = context.path[[context.path.length - 1]];\n      return [\n        {\n          message: propertyName + `: MUST not be defined using a $ref.`,\n        },\n      ];\n    }\n  }\n);"
    },
    {
      "id": "nfiSNHQHEHtWGvD7vgNLq",
      "extendedFrom": "",
      "name": "checkRequirements",
      "content": "import { createRulesetFunction } from '@stoplight/spectral-core';\n\n// List of accepted properties for all standards\nconst DCSA_PROPERTIES = {\n  bookingStatus: {propertyRequirements: {type: 'string', maxLength: 50} },\n  amendedBookingStatus: {propertyRequirements: {type: 'string', maxLength: 50} },\n  carrierBookingReference: {propertyRequirements: {type: 'string', maxLength: 35, pattern: \"^\\\\S+(\\\\s+\\\\S+)*$\"} },\n  carrierBookingRequestReference: {propertyRequirements: {type: 'string', maxLength: 100, pattern: \"^\\\\S+(\\\\s+\\\\S+)*$\"} },\n  reason: {propertyRequirements: {type: 'string', maxLength: 5000} },\n\n  // Notification - CloudEvent\n  specversion: {propertyRequirements: {type: 'string', enum: ['1.0']}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  id: {propertyRequirements: {type: 'string', maxLength: 100}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  source: {propertyRequirements: {type: 'string', maxLength: 4096}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  type: {propertyRequirements: {type: 'string'}, parents: {BookingNotification: {enum: ['org.dcsa.booking-notification.v2']},TransportDocumentNotification: {enum: ['org.dcsa.transport-document-notification.v3']}, ShippingInstructionsNotification: {enum: ['org.dcsa.shipping-instructions-notification.v3']} } },\n  time: {propertyRequirements: {type: 'string', format: 'date-time'}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  datacontenttype: {propertyRequirements: {type: 'string', enum: ['application/json']}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  data: {propertyRequirements: {type: 'object'}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n\n  // Testing the name property of vessel...\n  name: {propertyRequirements: {type: 'string'}, parents: {vessel: {} }},\n};\n\n//Booking\nconst BKG_API_100 = '1.0.0' + '|' + 'DCSA OpenAPI specification for Booking';\n//EBL\nconst EBL_API_100 = '1.0.0' + '|' + 'DCSA OpenAPI specification for Electronic Bill of Lading';\nconst EBL_API_200 = '2.0.0' + '|' + 'DCSA OpenAPI specification for Electronic Bill of Lading';\n//JIT\nconst JIT_API_120B1 = '1.2.0-Beta-1' + '|' + 'DCSA OpenAPI specification for Just in Time Portcalls';\nconst JIT_API_120B2 = '1.2.0-Beta-2' + '|' + 'DCSA OpenAPI specification for Just in Time Portcalls';\n//TNT\nconst TNT_API_220 = '2.2.0' + '|' + 'DCSA OpenAPI specification for Track & Trace';\n\n// A list of properties that have changed over time or are different for different standards\nconst DCSA_ADVANCED_PROPERTIES = {\n  equipmentReference: {\n    JIT_API_120B1: {propertyRequirements: {type: 'string', maxLength: 15}, parents: {} },\n    JIT_API_120B2: {propertyRequirements: {type: 'string', maxLength: 15}, parents: {} },\n    DEFAULT: {propertyRequirements: {type: 'string', maxLength: 11}, parents: {} }\n  },\n};\n\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction checkPropertyRequirements(input, propertyName, propertyRequirements, results) {\n  // Run through all required properties\n  for (const propertyKey of Object.keys(propertyRequirements)) {\n    // Test if the property exists on the input element\n    if (input[propertyKey]) {\n      // Checking enum as it needs to be treated specially\n      if (propertyKey === 'enum') {\n        // Check that enum values match (= are specified the same way...)\n        const enumValuesRequired = propertyRequirements[propertyKey];\n        const enumValues = input[propertyKey];\n        if (!arraysEqual(enumValues, enumValuesRequired)) {\n          // The two enum lists do not match - file an error\n          results.push( { message: propertyName + `.` + propertyKey + ` value must equal: [` + enumValuesRequired + `], value provided: [` + enumValues + `]`, }, );\n        }\n      // Checking a specific property\n      } else if (propertyRequirements[propertyKey] !== input[propertyKey]) {\n        // The value does not match - file an error\n        results.push( { message: propertyName + `.` + propertyKey + ` value must equal: ` + propertyRequirements[propertyKey] + `, value provided: ` + input[propertyKey], }, );\n      }\n    } else {\n      // The property is missing - file an error\n      results.push( { message: propertyName + `.` + propertyKey + ` value must equal: ` + propertyRequirements[propertyKey] + ` but nothing was provided.`, }, );\n    }\n  }\n}\n\nexport default createRulesetFunction(\n  {\n    input: null,\n    options: null,\n  },\n  function checkRequirements(input, options, context) {\n    const propertyName = context.path[[context.path.length - 1]];\n    let property = DCSA_PROPERTIES[propertyName];\n    if (property) {\n      // No DCSA properties can be defined using a $ref\n      if (Object.keys(input).length === 1 && input['$ref']) {\n        return [ { message: propertyName + ` MUST not be defined using a $ref`, }, ];\n      }\n      \n      // Gather all errors in results\n      const results = [];\n\n      // Test if there are any parent property requirements\n      let parents = property['parents'];\n      if (parents && Object.keys(parents).length > 0) {\n        const currentParent = context.path[[context.path.length - 3]];\n        const currentParentPropertyRequirements = parents[currentParent];\n        if (currentParentPropertyRequirements) {\n          // Check parent propertyRequirements\n          checkPropertyRequirements(input, propertyName, currentParentPropertyRequirements, results);\n        } else {\n          // The property MUST exist below one of the specified parents - if located elsewhere it is an error\n          return [ { message: propertyName + ` is only allowed under one of these parents: [` + Object.keys(parents) + `]`, }, ];\n        }\n      }\n\n      // Test for property requirements applicable to all locations\n      let propertyRequirements = property['propertyRequirements'];\n      checkPropertyRequirements(input, propertyName, propertyRequirements, results);\n\n      // Only return a list if it contains something - StopLight requirement\n      if (results.length > 0) {\n        return results;\n      }\n    } else {\n      // propertyName is not part of DCSA_PROPERTIES --> try it in the DCSA_ADVANCED_PROPERTIES\n      property = DCSA_ADVANCED_PROPERTIES[propertyName];\n      if (property) {\n        // TODO:...\n      } else {\n        // propertyName is not part of neither DCSA_PROPERTIES nor DCSA_ADVANCED_PROPERTIES\n        return [ { message: propertyName + ` is not in the list of DCSA approved property names`, }, ];\n      }\n    }\n  }\n);"
    }
  ],
  "extendedDefault": false
}