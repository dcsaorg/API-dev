{
  "name": "DCSA-OpenAPI",
  "description": "",
  "spectralExtends": [],
  "extends": [],
  "formats": [
    "oas2",
    "oas3",
    "oas3.0",
    "oas3.1"
  ],
  "aliases": {
    "DCSA_NonObjects": {
      "id": "wf_LHod3Y0nLDIuQp-ZaV",
      "description": "Matching all `DCSA` recognized simpleTypes",
      "name": "DCSA_NonObjects",
      "targets": [
        {
          "formats": [
            "oas3"
          ],
          "given": "$.components.schemas..properties.*"
        }
      ]
    }
  },
  "rules": {
    "simpleType-validation-check-DCSA-compatibility": {
      "id": "NcwDDKQv7GMS6sOLgRGBu",
      "given": [
        "#DCSA_NonObjects"
      ],
      "severity": "error",
      "then": {
        "function": "checkRequirements"
      },
      "name": "simpleType-validation-check-DCSA-compatibility",
      "description": "Check DCSA allowed properties",
      "message": "{{error}}",
      "resolved": false
    }
  },
  "x-embeddedFunctions": [
    {
      "id": "g2DJi6h7xrIe-ljcGXDj6",
      "extendedFrom": "",
      "name": "equals",
      "content": "import { createRulesetFunction } from '@stoplight/spectral-core';\n\nexport default createRulesetFunction(\n  {\n    input: null,\n    options: {\n      type: \"object\",\n      additionalProperties: false,\n      required: [\"value\"],\n\n      properties: {\n        value: {\n          type: [\"string\", \"integer\"]\n        }\n      }\n    },\n  },\n  // https://github.com/stoplightio/spectral/blob/develop/docs/guides/5-custom-functions.md#writing-functions\n  function equals(input, options, context) {\n    const { value } = options;\n\n    const propertyName = context.path[[context.path.length - 2]];\n    const propertyProperty = context.path[[context.path.length - 1]];\n    if (input !== undefined) {\n      if (input !== value) {\n      return [\n        {\n          message: propertyName + `.` + propertyProperty + `: value must equal \"${value}\", value provided: \"${input}\".`,\n        },\n      ];\n      }\n    } else {\n      return [\n        {\n          message: propertyName + `.` + propertyProperty + `: value must equal \"${value}\" no value provided!`,\n        },\n      ];\n    }\n  },\n);"
    },
    {
      "id": "UPXI6GiG0IVwCQgFhjc4t",
      "extendedFrom": "",
      "name": "noRefInSimpleType",
      "content": "import { createRulesetFunction } from '@stoplight/spectral-core';\n\nexport default createRulesetFunction(\n  {\n    input: null,\n    options: null,\n  },\n  // https://github.com/stoplightio/spectral/blob/develop/docs/guides/5-custom-functions.md#writing-functions\n  function noRefInSimpleType(input, options, context) {\n    if (Object.keys(input).length === 1 && input['$ref']) {\n      const propertyName = context.path[[context.path.length - 1]];\n      return [\n        {\n          message: propertyName + `: MUST not be defined using a $ref.`,\n        },\n      ];\n    }\n  }\n);"
    },
    {
      "id": "nfiSNHQHEHtWGvD7vgNLq",
      "extendedFrom": "",
      "name": "checkRequirements",
      "content": "import { createRulesetFunction } from '@stoplight/spectral-core';\n\n// List of attributes to be checked\n// For all attributes in ATTRIBUTES_TO_CHECK, this Spectral rule will make sure:\n// * if attribute is in the Spec - the attribute MUST also be in the requirements\n// * if attribute is in the requirements - then it also need to be in the Spec\nconst ATTRIUBTES_TO_CHECK= ['type', 'maxLength', 'pattern', 'enum', 'format', 'deprecated', 'discriminator', 'exclusiveMaximum', 'exclusiveMinimum', 'maximum', 'minimum'];\n\n// List of accepted properties for all standards\n// If 'parent' is specified - then the spec only allows the property under the list of parents\n// If no 'parent' is specified - the spec applies to all locations in the document\nconst DCSA_PROPERTIES = {\n  bookingStatus: {attributeRequirements: {type: 'string', maxLength: 50} },\n  amendedBookingStatus: {attributeRequirements: {type: 'string', maxLength: 50} },\n  carrierBookingReference: {attributeRequirements: {type: 'string', maxLength: 35, pattern: \"^\\\\S+(\\\\s+\\\\S+)*$\"} },\n  carrierBookingRequestReference: {attributeRequirements: {type: 'string', maxLength: 100, pattern: \"^\\\\S+(\\\\s+\\\\S+)*$\"} },\n  reason: {attributeRequirements: {type: 'string', maxLength: 5000} },\n\n  // Notification - CloudEvent\n  specversion: {attributeRequirements: {type: 'string', enum: ['1.0']}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  id: {attributeRequirements: {type: 'string', maxLength: 100}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  source: {attributeRequirements: {type: 'string', maxLength: 4096}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  type: {attributeRequirements: {type: 'string'}, parents: {BookingNotification: {enum: ['org.dcsa.booking-notification.v2']},TransportDocumentNotification: {enum: ['org.dcsa.transport-document-notification.v3']}, ShippingInstructionsNotification: {enum: ['org.dcsa.shipping-instructions-notification.v3']} } },\n  time: {attributeRequirements: {type: 'string', format: 'date-time'}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  datacontenttype: {attributeRequirements: {type: 'string', enum: ['application/json']}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n  data: {attributeRequirements: {type: 'object'}, parents: {ShippingInstructionsNotification: {},TransportDocumentNotification: {}, BookingNotification: {} } },\n\n  // Testing the name property of vessel...\n  name: {attributeRequirements: {type: 'string'}, parents: {vessel: {} }},\n};\n\n//Booking\nconst BKG_API_100 = '1.0.0' + '|' + 'DCSA OpenAPI specification for Booking';\n//EBL\nconst EBL_API_100 = '1.0.0' + '|' + 'DCSA OpenAPI specification for Electronic Bill of Lading';\nconst EBL_API_200 = '2.0.0' + '|' + 'DCSA OpenAPI specification for Electronic Bill of Lading';\n//JIT\nconst JIT_API_120B1 = '1.2.0-Beta-1' + '|' + 'DCSA OpenAPI specification for Just in Time Portcalls';\nconst JIT_API_120B2 = '1.2.0-Beta-2' + '|' + 'DCSA OpenAPI specification for Just in Time Portcalls';\n//TNT\nconst TNT_API_220 = '2.2.0' + '|' + 'DCSA OpenAPI specification for Track & Trace';\n\n// A list of properties that have changed over time or are different for different standards\nconst DCSA_ADVANCED_PROPERTIES = {\n  equipmentReference: {\n    JIT_API_120B1: {propertyRequirements: {type: 'string', maxLength: 15}, parents: {} },\n    JIT_API_120B2: {propertyRequirements: {type: 'string', maxLength: 15}, parents: {} },\n    DEFAULT: {propertyRequirements: {type: 'string', maxLength: 11}, parents: {} }\n  },\n};\n\n// Makes sure two arrays are equal if:\n// * they are the same array\n// * they have the same size\n// * items on each posibition in the list are the same\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction checkRequirement(input, propertyName, attribute, requirements, results) {\n  if (attribute === 'enum') {\n    // Check that enum values match (= are specified the same way...)\n    const enumValuesRequired = requirements[attribute];\n    const enumValues = input[attribute];\n    if (!arraysEqual(enumValues, enumValuesRequired)) {\n      // The two enum lists do not match - file an error\n      results.push( { message: propertyName + `.` + attribute + ` value must equal: [` + enumValuesRequired + `], value provided: [` + enumValues + `]`, }, );\n    }\n  // Checking a specific attribute\n  } else if (requirements[attribute] !== input[attribute]) {\n    // The value provided and the value required does not match - file an error\n    results.push( { message: propertyName + `.` + attribute + ` value must equal: ` + requirements[attribute] + `, value provided: ` + input[attribute], }, );\n  }\n\n  // Make sure type attributes that are strings have example attriubte value set\n  if (attribute === 'type' && requirements[attribute] === \"string\" && (!input['example'] || input['example'].length === 0)) {\n    // Example value missing when type=string - file an error\n    results.push( { message: propertyName + `.example attribute must be set with a value`, }, );\n  }\n}\n\nfunction checkAttributeRequirements(input, propertyName, parentPropertyName, attributeRequirements, currentParentAttributeRequirements, results) {\n  for (const attribute of ATTRIUBTES_TO_CHECK) {\n    if (input[attribute]) {\n      // The attribute exists in the Spec\n      if (attributeRequirements[attribute]) {\n        checkRequirement(input, propertyName, attribute, attributeRequirements, results);\n      } else if (currentParentAttributeRequirements && currentParentAttributeRequirements[attribute]) {\n        checkRequirement(input, propertyName, attribute, currentParentAttributeRequirements, results);\n      } else {\n        // The attribute exists only in the Spec - NOT in the required fields in neither current or parent requirements - file an error\n        results.push( { message: propertyName + `.` + attribute + ` is specified - but should be removed as it is not a required attribute`, }, );\n      }\n    } else if (attributeRequirements[attribute]) {\n      // The attribute exists only in the required fields - NOT in the Spec\n      if (attribute === 'enum') {\n        // Provide better error message for missing enum\n        results.push( { message: propertyName + `.enum must contain the list: [` + attributeRequirements[attribute] + `] but nothing was provided`, }, );\n      } else {\n        results.push( { message: propertyName + `.` + attribute + ` value must equal: ` + attributeRequirements[attribute] + ` but nothing was provided`, }, );\n      }\n    } else if (currentParentAttributeRequirements && currentParentAttributeRequirements[attribute]) {\n      // The attribute exists only in the required fields of the parent - NOT in the Spec\n      if (attribute === 'enum') {\n        // Provide better error message for missing enum\n        results.push( { message: propertyName + `.enum must contain the list: [` + currentParentAttributeRequirements[attribute] + `] when defined under the parent property: ` + parentPropertyName + ` but nothing was provided`, }, );\n      } else {\n        results.push( { message: propertyName + `.` + attribute + ` value must equal: ` + currentParentAttributeRequirements[attribute] + ` when defined under the parent property: ` + parentPropertyName + ` but nothing was provided`, }, );\n      }\n    } else {\n      // In none of the lists - there is no requiement for this attribute\n    }\n  }\n}\n\nexport default createRulesetFunction(\n  {\n    input: null,\n    options: null,\n  },\n  function checkRequirements(input, options, context) {\n    // Get current DCSA_property to check\n    const propertyName = context.path[[context.path.length - 1]];\n    let property = DCSA_PROPERTIES[propertyName];\n    if (property) {\n      // No DCSA properties can be defined using a $ref - file an error\n      if (Object.keys(input).length === 1 && input['$ref']) {\n        return [ { message: propertyName + ` MUST not be defined using a $ref`, }, ];\n      }\n      \n      // Gather all errors in results\n      const results = [];\n\n      // Get default attribute requirements applicable to all locations\n      let attributeRequirements = property['attributeRequirements'];\n\n      // Test if there are any parent attribute requirements\n      let parents = property['parents'];\n      // If parent is defined - the required attributes only apply under a parent\n      if (parents && Object.keys(parents).length > 0) {\n        // Get parent to DCSA_property\n        const parentPropertyName = context.path[[context.path.length - 3]];\n        const parentAttriubteRequirements = parents[parentPropertyName];\n        if (parentAttriubteRequirements) {\n          // Check parent attributeRequirements\n          checkAttributeRequirements(input, propertyName, parentPropertyName, attributeRequirements, parentAttriubteRequirements, results);\n        } else {\n          // The attribute MUST exist below one of the specified parents - if located elsewhere it is an error\n          return [ { message: propertyName + ` is only allowed under one of these parents: [` + Object.keys(parents) + `]`, }, ];\n        }\n      } else {\n        // No parent is defined - so the check applies to all locations\n        checkAttributeRequirements(input, propertyName, null, attributeRequirements, null, results);\n      }\n\n      // Only return a list if it contains something - StopLight requirement!!\n      if (results.length > 0) {\n        return results;\n      }\n    } else {\n      // propertyName is not part of DCSA_PROPERTIES --> try it in the DCSA_ADVANCED_PROPERTIES\n      property = DCSA_ADVANCED_PROPERTIES[propertyName];\n      if (property) {\n        // TODO:...\n      } else {\n        // propertyName is not part of neither DCSA_PROPERTIES nor DCSA_ADVANCED_PROPERTIES\n        return [ { message: propertyName + ` is not in the list of DCSA approved property names`, }, ];\n      }\n    }\n  }\n);"
    }
  ],
  "extendedDefault": false
}